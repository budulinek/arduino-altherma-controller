/* Altherma UDP Controller: Monitors and controls Daikin E-Series (Altherma) het pumps through P1/P2 bus.

  Version history
  v0.1 2020-11-30 Initial commit, save history of selected packets, settings
  v0.2 2020-12-05 Hysteresis, vertify commands sent to P1P2
  v0.3 2020-12-09 More effective and reliable writing to P1P2 bus
  v0.4 2020-12-10 Minor tweaks
  v1.0 2023-04-18 Major upgrade: web interface, store settings in EEPROM, P1P2 error counters

 */

const byte VERSION[] = { 1, 0 };

#include <SPI.h>
#include <Ethernet.h>
#include <EthernetUdp.h>
#include <utility/w5100.h>
#include <CircularBuffer.h>  // CircularBuffer https://github.com/rlogiacco/CircularBuffer
#include <EEPROM.h>
#include <StreamLib.h>  // StreamLib https://github.com/jandrassy/StreamLib
// #include <P1P2Serial.h>  // P1P2Serial https://github.com/Arnold-n/P1P2Serial
#include "src/P1P2Serial_mod/P1P2Serial_mod.h"  // modified P1P2Serial library

// these are used by CreateTrulyRandomSeed() function
#include <avr/interrupt.h>
#include <avr/wdt.h>
#include <util/atomic.h>


enum first_last : byte {
  FIRST,
  LAST
};

enum status : byte {
  PACKET_SEEN,  // Packet Type was detected on P1P2 bus
  PACKET_SENT,  // Packet is sent via UDP
  PACKET_LAST   // Number of status flags in this enum. Must be the last element within this enum!!
};

enum mode : byte {
  CONTROL_DISABLED,  // Disabled
  CONTROL_MANUAL,    // Manual Connect
  CONTROL_AUTO       // Auto Connect
};

typedef struct {
  byte macEnd[3];
  byte ip[4];
  byte subnet[4];
  byte gateway[4];
  byte dns[4];      // only used if ENABLE_DHCP
  bool enableDhcp;  // only used if ENABLE_DHCP
  byte remoteIp[4];
  bool udpBroadcast;
  unsigned int udpPort;
  unsigned int webPort;
  byte controllerMode;
  byte connectTimeout;
  bool notSupported;
  byte hysteresis;
  bool sendAllPackets;
  byte counterPeriod;
  bool saveDataPackets;
  uint8_t packetStatus[PACKET_LAST][256 / 8];
} config_type;

// local configuration values (stored in RAM)
config_type localConfig;

#include "advanced_settings.h"

// each request is stored in 3 queues (all queues are written to, read and deleted in sync)
CircularBuffer<byte, MAX_QUEUE_DATA> cmdQueue;  // queue of PDU data


/****** ETHERNET AND P1P2 SERIAL ******/

byte maxSockNum = MAX_SOCK_NUM;

#ifdef ENABLE_DHCP
bool dhcpSuccess = false;
#endif /* ENABLE_DHCP */

EthernetUDP Udp;
EthernetServer webServer(DEFAULT_CONFIG.webPort);

#define SPI_CLK_PIN_VALUE (PINB & 0x20)

P1P2Serial P1P2Serial;
static byte hwID = 0;

/****** TIMERS AND STATE MACHINE ******/

class Timer {
private:
  unsigned long timestampLastHitMs;
  unsigned long sleepTimeMs;
public:
  boolean isOver();
  void sleep(unsigned long sleepTimeMs);
};
boolean Timer::isOver() {
  if ((unsigned long)(millis() - timestampLastHitMs) > sleepTimeMs) {
    return true;
  }
  return false;
}
void Timer::sleep(unsigned long sleepTimeMs) {
  this->sleepTimeMs = sleepTimeMs;
  timestampLastHitMs = millis();
}

Timer eepromTimer;          // timer to delay writing statistics to EEPROM
Timer connectionTimer;      // timer to monitor connection status
Timer counterRequestTimer;  // 0xB8 counter request

enum state : byte {
  DISABLED,
  DISCONNECTED,
  CONNECTING,
  CONNECTED,
  NOT_SUPPORTED
};

byte controllerState;
byte controllerId = 0x00;

// FxAbsentCnt[x] counts number of unanswered 00Fx30 messages;
// if -1 than no Fx request or response seen (relevant to detect whether F1 controller is supported or not)
static int8_t FxAbsentCnt[2] = { -1, -1 };

void (*resetFunc)(void) = 0;  //declare reset function at address 0

/****** RUN TIME AND DATA COUNTERS ******/

byte savedPackets[SAVED_PACKETS_SIZE] = {};
byte saved36Params[MAX_36_PARAMS + 1][2];  // storage for 0x36 parameters, param value is s16 (2 bytes)
const byte PACKET_TYPE_HANDSHAKE = PACKET_TYPE_CONTROL[FIRST];

const byte NAME_SIZE = 16;  // buffer size for device name
char daikinIndoor[NAME_SIZE];
char daikinOutdoor[NAME_SIZE];
bool indoorInQueue;   // request for an indoor name in queue
bool outdoorInQueue;  // request for an outdoor name in queue

volatile uint32_t seed1;  // seed1 is generated by CreateTrulyRandomSeed()
volatile int8_t nrot;
uint32_t seed2 = 17111989;  // seed2 is static

enum p1p2_Error : byte {
  P1P2_READ,         // Read
  P1P2_WRITTEN,      // Written
  P1P2_ERROR_PE,     // Parity Read Error
  P1P2_LARGE,        // Read Too Long
  P1P2_ERROR_SB,     // Start Bit Write Error
  P1P2_ERROR_BE_BC,  // Write Bus Collission
  P1P2_ERROR_OR,     // Buffer Overrun
  P1P2_ERROR_CRC,    // CRC Error
  P1P2_LAST          // Number of status flags in this enum. Must be the last element within this enum!!
};
// array for storing P1P2 counters
uint32_t p1p2Count[P1P2_LAST];

typedef struct {
  uint32_t eepromWrites;     // Number of Arduino EEPROM write cycles
  uint32_t daikinWrites;     // Number of Daikin EEPROM write cycles
  byte eepromDate[6];        // Time and date when Daikin EEPROM write cycles counter started
  uint16_t todayWrites;      // Number of Daikin EEPROM write cycles today
  uint16_t yesterdayWrites;  // Number of Daikin EEPROM write cycles yesterday
} struct_eeprom;

struct_eeprom eepromCount;

byte date[6];  // Date and time from Daikin Unit

#ifdef ENABLE_EXTRA_DIAG
enum udp_Error : byte {
  UDP_SENT,      // Sent to UDP
  UDP_RECEIVED,  // Received from UDP
  UDP_LAST       // Number of status flags in this enum. Must be the last element within this enum!!
};
// array for storing UDP counters
uint32_t udpCount[UDP_LAST];

// store uptime seconds (includes seconds counted before millis() overflow)
unsigned long seconds;
// store last millis() so that we can detect millis() overflow
unsigned long last_milliseconds = 0;
// store seconds passed until the moment of the overflow so that we can add them to "seconds" on the next call
long remaining_seconds;
#endif /* ENABLE_EXTRA_DIAG */

/****** SETUP: RUNS ONCE ******/



void setup() {
  Serial.begin(115200);

  // for (int i = 0; i < EEPROM.length(); i++) {
  //   EEPROM.write(i, 0);
  // }

  CreateTrulyRandomSeed();

  int address = CONFIG_START;
  EEPROM.get(address, eepromCount);  // EEPROM counters are persistent, never cleared during factory resets
  address += sizeof(eepromCount);
  // is config already stored in EEPROM?
  if (EEPROM.read(address) == VERSION[0]) {
    // load local configuration struct from EEPROM, from CONFIG_START address
    address += 1;
    EEPROM.get(address, localConfig);
    address += sizeof(localConfig);
    EEPROM.get(address, p1p2Count);
#ifdef ENABLE_EXTRA_DIAG
    address += sizeof(p1p2Count);
    EEPROM.get(address, udpCount);
#endif /* ENABLE_EXTRA_DIAG */
  } else {
    // load default configuration from flash memory
    localConfig = DEFAULT_CONFIG;
    // Send data packets (0x10-0x16) and counter packet (0xB8) by default
    setPacketStatus(PACKET_TYPE_COUNTER, PACKET_SENT, true);
    for (byte i = PACKET_TYPE_DATA[FIRST]; i <= PACKET_TYPE_DATA[LAST]; i++) {
      setPacketStatus(i, PACKET_SENT, true);
    }
    // generate new MAC (bytes 0, 1 and 2 are static, bytes 3, 4 and 5 are generated randomly)
    generateMac();
    // save configuration (incl. last 3 bytes of MAC) to EEPROM
    updateEeprom();
  }
  startEthernet();

  memset(savedPackets, 0xFF, sizeof(savedPackets));  // initial value for all saved packets is 0xFF

  hwID = SPI_CLK_PIN_VALUE ? 0 : 1;
  P1P2Serial.begin(9600, hwID ? true : false, 6, 7);  // if hwID = 1, use ADC6 and ADC7
  P1P2Serial.setEcho(true);                           // defines whether written data is read back and verified against written data (advise to keep this 1)
  P1P2Serial.setDelayTimeout(INIT_SDTO);

  // initialize P1P2 connection
  if (localConfig.controllerMode == CONTROL_AUTO && !localConfig.notSupported) {
    controllerState = CONNECTING;
    connectionTimer.sleep(localConfig.connectTimeout * 1000UL);
  } else if (localConfig.controllerMode == CONTROL_DISABLED) {
    controllerState = DISABLED;
  } else {
    controllerState = DISCONNECTED;
  }
  eepromTimer.sleep(EEPROM_INTERVAL * 60UL * 60UL * 1000UL);  // EEPROM_INTERVAL is in hours, sleep is in milliseconds!
}

void loop() {

  // rcvSerial();
  recvBus();
  recvUdp();
  manageSockets();

  manageController();

  if (rollover()) {
    resetStats();
  }

  if (EEPROM_INTERVAL > 0 && eepromTimer.isOver() == true) {
    updateEeprom();
  }

#ifdef ENABLE_EXTRA_DIAG
  maintainUptime();  // maintain uptime in case of millis() overflow
#endif               /* ENABLE_EXTRA_DIAG */
#ifdef ENABLE_DHCP
  maintainDhcp();
#endif /* ENABLE_DHCP */
}
